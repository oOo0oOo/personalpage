<!DOCTYPE html>
<html lang="en">
<head>
  <title>Oli.show</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@100;300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
  <script src="https://unpkg.com/htmx.org@1.8.4"></script>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';

    import {CONFIG, COLOR_SCHEME} from './config.js';

    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);

    const SCREEN_WIDTH = window.innerWidth;
    const SCREEN_HEIGHT = window.innerHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color( COLOR_SCHEME[1] );

    // 3D RENDERER, CAMERA & CONTROLS
    const camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 1000 );

    const raycaster = new THREE.Raycaster();

    camera.position.z = 40;
    camera.position.y = 13;
    var currentFocus = "sun";

    var auto_zoom = true;
    window.addEventListener('wheel', (event) => {
        auto_zoom = false;
    });

    var labels = {};

    // // UI CAMERA (2D)

    // Create the camera and set the viewport to match the screen dimensions.
    var cameraHUD = new THREE.OrthographicCamera(-SCREEN_WIDTH/2, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, -SCREEN_HEIGHT/2, 0, 1000 );

    // Create also a custom scene for HUD.
    var sceneHUD = new THREE.Scene();

    // RENDERER
    var renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.autoClear = false;
    renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

    document.body.appendChild( renderer.domElement );

    const controls = new OrbitControls( camera, renderer.domElement );

    // FONTS from google fonts
    var font_regular = new FontLoader("Barlow", 'http://fonts.gstatic.com/s/barlow/v12/7cHpv4kjgoGqM7E_DMs5.woff2');

    function createLabel(body){
        // We will use 2D canvas element to render our HUD.  
        var hudCanvas = document.createElement('canvas');

        // Again, set dimensions to fit the screen.
        hudCanvas.width = SCREEN_WIDTH;
        hudCanvas.height = SCREEN_HEIGHT;

        // Get 2D context and draw something supercool.
        var hudBitmap = hudCanvas.getContext('2d');

        // Background color
        hudBitmap.fillStyle = "#88A47C22";

        // Width is dependent on the length of the text
        var width = body.config.title.length;
        width *= 36;
        width += 80;
        var height = 150;
        hudBitmap.fillRect(512 - width/2, 410, width, height);

        // Draw the text
        hudBitmap.font = "50pt Barlow";
        hudBitmap.textAlign = 'center';
        hudBitmap.fillStyle = "#E6E2C3";
        hudBitmap.fillText(body.config.title, CONFIG.LABEL_SIZE[0], CONFIG.LABEL_SIZE[1]);

        // Create texture from rendered graphics.
        var hudTexture = new THREE.Texture(hudCanvas) 
        hudTexture.needsUpdate = true;

        // Create HUD material.
        var materialHUD = new THREE.MeshBasicMaterial( {map: hudTexture} );
        materialHUD.transparent = true;

        // Create plane to render the HUD. This plane fill the whole screen.
        var planeGeometry = new THREE.PlaneGeometry( CONFIG.LABEL_SIZE[0], CONFIG.LABEL_SIZE[1] );
        // planeGeometry.rotate = {x: 0, y: Math.PI, z: 0};
        var plane = new THREE.Mesh( planeGeometry, materialHUD );
        sceneHUD.add( plane );

        console.log("Created label for " + body.config.title);
        return plane;
    }

    function updateLabels(){
        // Remove all labels (dictionary)
        Object.keys(labels).forEach(function(key) {
            sceneHUD.remove(labels[key]);
        });
        labels = {};

        // Label all children of current focus
        if (currentFocus == "sun"){
            Object.keys(categories).forEach(function(key) {
                labels[key] = createLabel(categories[key]);
            });
        // If it is a planet we label all moons
        } else if (categories[currentFocus]){
            Object.keys(projects).forEach(function(key) {
                if (projects[key].config.parent == currentFocus) {
                    labels[key] = createLabel(projects[key]);
                }
            });
        }

        // The y position of the labels alternates between the LABEL_Y_OFFSETS
        var label_y_offset = 0;
        Object.keys(labels).forEach(function(key, index) {
            var extra = CONFIG.LABEL_Y_STEP * Math.floor(index / 2);
            labels[key].position.y = CONFIG.LABEL_Y_OFFSETS[label_y_offset] + extra;
            label_y_offset = (label_y_offset + 1) % CONFIG.LABEL_Y_OFFSETS.length;
        });
    }

    // const ui_camera = new THREE.OrthographicCamera( -SCREEN_WIDTH / 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, -SCREEN_HEIGHT / 2, 1, 1000 );
    // scene.add(ui_camera);

    function create_body(body_config, orbit) {
        var radius_range;
        var color;
        var scaled_orbit;
        orbit += Math.random() * 2 * CONFIG.ORBIT_RANDOM - CONFIG.ORBIT_RANDOM;

        if (body_config.parent) {
            radius_range = CONFIG.RADIUS_MOON;
            color = CONFIG.COLOR_MOON;
            scaled_orbit = CONFIG.SCALE_MOON_ORBIT * (0.3 + 0.7 * orbit);
        } else {
            radius_range = CONFIG.RADIUS_PLANET;
            color = CONFIG.COLOR_PLANET;
            scaled_orbit = CONFIG.SCALE_PLANET_ORBIT * (0.2 + 0.8 * orbit);
        }

        var radius = radius_range[0] + Math.random() * (radius_range[1] - radius_range[0]);
        const geometry = new THREE.SphereGeometry(radius, 16, 16);
        const material = new THREE.MeshBasicMaterial({color: color});
        const body = new THREE.Mesh(geometry, material);
        body.name = body_config.id;
        scene.add( body );

        if (body_config.parent == null) {
            // Create trailing curve for the body
            var curve = new THREE.EllipseCurve(
                0,  0,            // ax, aY
                scaled_orbit, scaled_orbit,           // xRadius, yRadius
                0,  2 * Math.PI,  // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );

            const num_points = 50 + Math.floor(orbit * 50);
            const points = curve.getPoints(num_points);

            // Convert 2D points to 3D points with z = y
            for (var i = 0; i < points.length; i++) {
                points[i].z = points[i].y;
                points[i].y = 0;
            }

            const geometryCurve = new THREE.BufferGeometry().setFromPoints( points );
            const materialCurve = new THREE.LineBasicMaterial( { color: CONFIG.COLOR_ORBIT } );

            // Create the final object to add to the scene
            const ellipse = new THREE.Line( geometryCurve, materialCurve );

            scene.add(ellipse);
        };

        var body_config = {
            body: body,
            curve: curve,
            config: body_config,
            orbit: scaled_orbit,
            angular_velocity: Math.sqrt(CONFIG.GRAVITY / scaled_orbit),
            angle: 2 * Math.PI * Math.random(),
        };

        return body_config;
    };

    // POPULATE THE SCENE

    var clickable = [];

    // Create the sun
    const geometry = new THREE.SphereGeometry(CONFIG.RADIUS_SUN, 16, 16);
    const material = new THREE.MeshBasicMaterial({color: CONFIG.COLOR_SUN});
    const sun = new THREE.Mesh(geometry, material);
    sun.name = "sun";
    scene.add( sun );
    clickable.push(sun);

    // Create all the categories
    var categories = {};
    var orbits = {};
    CONFIG.categories.forEach(function(body_config, index) {
        var orbit = index / CONFIG.categories.length;
        var body = create_body(body_config, orbit);
        categories[body_config.id] = body;
        orbits[body_config.id] = [];
        clickable.push(body.body);
    });

    // Create all projects
    CONFIG.projects.forEach(function(body_config) {
        orbits[body_config.parent].push(body_config.id);
    });

    var projects = {};
    CONFIG.projects.forEach(function(body_config) {
        var orbit = orbits[body_config.parent].indexOf(body_config.id);
        orbit /= orbits[body_config.parent].length;
        var body = create_body(body_config, orbit);
        projects[body_config.id] = body;
        clickable.splice(0, 0, body.body);
    });

    var last_time = 0;
    const start_time = Date.now();

    function update() {
        var frame = requestAnimationFrame( update );

        // Calculate fps
        const delta = Date.now() - last_time;
        last_time += delta;
        var time = last_time - start_time;

        // Update all planet positions
        var pos = {"sun": {x: 0, y:0, z: 0}};
        var target_is_planet = false;
        Object.values(categories).forEach(function(body_config) {
            const angle = body_config.angle + time * body_config.angular_velocity;

            const x =  body_config.orbit * Math.cos(angle);
            const z = body_config.orbit * Math.sin(angle);
            body_config.body.position.set(x, 0, z);
            pos[body_config.config.id] = {x: x, y:0, z: z};
            if (body_config.config.id == currentFocus) {
                target_is_planet = true;
            }
        });

        // Update all moon positions
        Object.values(projects).forEach(function(body_config) {
            const angle = body_config.angle + time * body_config.angular_velocity;

            const x =  pos[body_config.config.parent].x + body_config.orbit * Math.cos(angle);
            const z =  pos[body_config.config.parent].z + body_config.orbit * Math.sin(angle);
            body_config.body.position.set(x, 0, z);
            pos[body_config.config.id] = {x: x, y:0, z: z};
        });

        var focus_pos = pos[currentFocus];
        var current_pos = controls.target;

        // move towards correct position
        var diff = {x: focus_pos.x - current_pos.x, z: focus_pos.z - current_pos.z};
        var dist = Math.sqrt(diff.x * diff.x + diff.z * diff.z);

        // ease towards the correct position
        if (dist > 0.1) {
            controls.target.x += CONFIG.PAN_SPEED * diff.x;
            controls.target.z += CONFIG.PAN_SPEED * diff.z;
            controls.update();
        } else {
            controls.target.copy(focus_pos);
            controls.update();
        }

        // Also try to move the camera to a certain distance from the focus
        if (auto_zoom){
            var target_pos = controls.target.clone();
            var target_distance;
            if (currentFocus == "sun") {
                // target_pos.y = CONFIG.HEIGHT_SUN;
                target_distance = CONFIG.DISTANCE_SUN;
            } else if (target_is_planet) {
                // target_pos.y = CONFIG.HEIGHT_PLANET;
                target_distance = CONFIG.DISTANCE_PLANET;
            } else {
                // target_pos.y = CONFIG.HEIGHT_MOON;
                target_distance = CONFIG.DISTANCE_MOON;
            }

            var current_distance = camera.position.distanceTo(target_pos);

            var distance_diff = target_distance - current_distance;
            if (Math.abs(distance_diff) > 0.1) {
                var direction = camera.position.clone().sub(controls.target).normalize();
                camera.position.add(direction.multiplyScalar(CONFIG.ZOOM_SPEED * distance_diff));
                camera.updateProjectionMatrix();
            }
        }

        // Now move all the labels to above the correct planet
        if (currentFocus == "sun") {
            // Move all planet labels to the corresponding planet
            Object.values(categories).forEach(function(body_config) {
                var pos = body_config.body.position.clone();

                // Find where in the hud the planet is
                var vector = pos.project(camera);
                
                // Move the label to the correct position
                labels[body_config.config.id].position.x = vector.x * SCREEN_WIDTH / 2;
            });
        } else if (categories[currentFocus]){
            // Move all moon labels to the corresponding moon
            Object.values(projects).forEach(function(body_config) {
                if (body_config.config.parent == currentFocus) {
                    var pos = body_config.body.position.clone();

                    // Find where in the hud the planet is
                    var vector = pos.project(camera);
                    
                    // Move the label to the correct position
                    labels[body_config.config.id].position.x = vector.x * SCREEN_WIDTH / 2;
                }
            });
        }

        renderer.render( scene, camera );

        // Render HUD on top of the scene.
        renderer.render( sceneHUD, cameraHUD );
    };

    var drag_distance = 0;
    var is_dragging = false;

    function onDocumentMouseDown( e ) {
        drag_distance = 0;
        is_dragging = true;
        e.preventDefault();
    }

    function checkMouseClick(e){
        var mouseVector = new THREE.Vector3();
        mouseVector.x = 2 * (e.clientX / SCREEN_WIDTH) - 1;
        // Add cursor height??
        mouseVector.y = 1 - 2 * ( e.clientY / SCREEN_HEIGHT );
        raycaster.setFromCamera(mouseVector, camera);

        // Intersect with plane
        var plane = new THREE.Plane(new THREE.Vector3(0, 1, 0));
        var intersection = new THREE.Vector3();
        raycaster.ray.intersectPlane( plane, intersection );

        // Check if the intersection point is on a body
        var oldFocus = currentFocus;
        var found = false;
        for (var i = 0; i < clickable.length; i++) {
            var body = clickable[i];
            var distance = body.position.distanceTo(intersection);

            var threshold;
            if (body.name == "sun") {
                threshold = CONFIG.RADIUS_SUN;
            } else if (categories[body.name]) {
                threshold = CONFIG.RADIUS_PLANET[1];
            } else {
                threshold = CONFIG.RADIUS_MOON[1];
            }
            
            if (distance < threshold * CONFIG.EXTRA_RADIUS) {
                // Focused on the sun: we should only be able to focus on planets
                if (currentFocus == "sun"){
                    if (categories[body.name]) {
                        currentFocus = body.name;
                    } else {
                        currentFocus = projects[body.name].config.parent;
                    }
                // Focused on a planet: we should only be able to focus on moons of this planet, the sun or other planets
                } else if (categories[currentFocus]) {
                    if (projects[body.name] && projects[body.name].config.parent == currentFocus) {
                        currentFocus = body.name;
                    } else if (categories[body.name]) {
                        currentFocus = body.name;
                    } else {
                        currentFocus = projects[body.name].config.parent;
                    }
                }
                // Focused on a moon: can focus on all planets, the sun, moons only of the same planet
                else {
                    if (categories[body.name]) {
                        currentFocus = body.name;
                    } else if (projects[body.name] && projects[body.name].config.parent == currentFocus) {
                        currentFocus = body.name;
                    } else {
                        currentFocus = projects[body.name].config.parent;
                    }
                }

                found = true;
                auto_zoom = true;
                break;
            }
        }

        // Click current focus: move to parent
        if (oldFocus == currentFocus && found && auto_zoom) {
            if (categories[currentFocus]) {
                currentFocus = "sun";
            } else {
                currentFocus = projects[currentFocus].config.parent;
            }
            auto_zoom = true;
        }

        if (oldFocus != currentFocus) {
            updateLabels();
        }
    }

    function onDocumentMouseMove( e ) {
        if (is_dragging) {
            if (drag_distance < 10) {
                drag_distance += Math.abs(e.movementX) + Math.abs(e.movementY);
            }
        }
    }

    function onDocumentMouseUp( e) {
        if (drag_distance < 10) {
            checkMouseClick(e);
        }
    }

    updateLabels();
    update();
  </script>
</body>
</html>